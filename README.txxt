We're going to write a lua library that handles hierarchical configuration.  

Here's the problem definition: 

- Application has a set of default config values.
- User has user preferences (typically in ~/.someapp or ~/.config/someapp/)
- At run time, there's object specific values (like a .somapp file in  directory defining that directories choices)
- Envriroment varaiables

These are to be applied in a predictable precedence order, being the less to more specfic (in the list above each new point trumps the previous values). 


This is part of the core functionality  of the lib: do a deep merge , respecting precedece order. 

Another one, is to be able to convert varioius config formats into an  internal representation (a lua table). This tends to be straight forward when dealing with structured data like toml or json but needs to be addressed on how env varis will map. 

For env vars: 
	application defines a prefix MYAPP_
	dots (new hierarchical nodes are mapped to _)
	applciation iterates throgh all env varis and process the ones with which match the prefix


Api: 
support two styles: chained and iterative as in 

-- 2. In your main application file:
local merger = require("path.to.your.configmerger")

local config = merger.
    :add_defaults(require("myapp.defaults"))
    :add__config(os.getenv("HOME") .. "/.myapp/config.lua")
    :add__config(".myapprc")
    :add_env_vars("MYAPP_")

-- Now access configuration
local value1 = config.get("setting1")
local value2 = config.get("nested.sub_setting")

print("Setting 1:", value1)
print("Nested Sub Setting:", value2)

-- You could also potentially get the raw table
-- local full_config = config:get_table()
-- print(full_config.setting2)


local config = merger.merge({
    { type = "defaults", source = require("myapp.defaults") },
    { type = "file", path = os.getenv("HOME") .. "/.myapp/config.lua" },
    { type = "file", path = ".myapprc" },
    { type = "env", prefix = "MYAPP_" }
})


We can begin by supporting lua tables, env varis and toml files, but it wouldb nice to structure this so that we can add new file readers by adding a registry like thing passing the function that converts the stream/file to a lua haash

the library is called lua-melt and sould live under melt, and it's tests in spec/melt